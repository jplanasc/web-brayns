/**
 * Communication to Brayns service is made through WebSocket.
 */
import Tfw from 'tfw'
import React from 'react'
import Listeners from '../../tfw/listeners'
import { IAsyncQuery } from '../types'

interface IQuery {
    id: string,
    method: string,
    params: any,
    resolve: (data: any) => void
    reject: (data: { code: number, message: string }) => void
}

interface IQueries {
    [key: string]: IQuery
}

interface ISubscribers {
    [key: string]: Listeners<{}>
}

export default class BraynsService {
    debug: boolean = false
    private ws: WebSocket | undefined
    private autogeneratedId: number = 1
    private queries: IQueries = {}
    readonly readyListeners = new Listeners<boolean>()
    readonly binaryListeners = new Listeners<ArrayBuffer>()
    readonly subscribers: ISubscribers = {}
    private host = ""

    async connect(hostname: string | null = null): Promise<boolean> {
        this.host = hostname || this.host
        const url = `ws://${this.host}/ws`

        return new Promise((resolve, reject) => {
            try {
                const handleResolve = () => {
                    ws.removeEventListener('open', handleResolve)
                    resolve(true)
                }
                const handleReject = (evt: any) => {
                    console.error(`Unable to connect to ${url}!`, evt)
                    ws.removeEventListener('close', handleReject)
                    ws.removeEventListener('error', handleReject)
                    resolve(false)
                }

                // The protocol ("rocjets") is mandatory otherwise Brayns will ignore you.
                console.log("WebSocket connection to", url, " with protocol 'rocket'...")
                const ws = new WebSocket(url, ["rockets"])
                console.log("...success!")
                // This is very IMPORTANT! With blobs,
                // we have weird bugs when trying to get the videostreaming messages.
                ws.binaryType = 'arraybuffer'
                ws.addEventListener('open', this.handleOpen)
                ws.addEventListener('open', handleResolve)
                ws.addEventListener('message', this.handleMessage)
                ws.addEventListener('close', this.handleClose)
                ws.addEventListener('close', handleReject)
                ws.addEventListener('error', this.handleError)
                ws.addEventListener('error', handleReject)
                this.ws = ws
            } catch (ex) {
                console.error(`Unable to connect to WebSocket rocket "${url}:"`, ex)
                reject(ex)
            }
        })
    }

    nextId(): string {
        return btoa(`${this.autogeneratedId++}`)
    }

    exec(method: string, params: any = {}) {
        return new Promise((resolve, reject) => {
            try {
                const id = this.nextId()
                //this.log({ id, method, params });
                const protocol = {
                    jsonrpc: "2.0",
                    id,
                    method,
                    params
                }
                if (!this.ws) return;
                this.queries[id] = { id, method, params, resolve, reject }
                this.ws.send(JSON.stringify(protocol));
            }
            catch (ex) {
                console.error("WS: ", ex)
                reject(ex)
            }
        })
    }

    /**
     * Send an asynchronous query. This is a cancellable query with progress.
     * Return IAsyncQuery {
     *     cancel: () => void,
     *     progress: Listeners<(label: string, progress: number) => void>,
     *     promise: Promise<IAsyncExecResolve>
     * }
     */
    execAsync(method: string, params: any = {}): IAsyncQuery {
        const that = this
        const listeners = new Listeners<{ label: string, progress: number }>()
        const id = this.nextId()

        const promise = new Promise((resolve, reject) => {
            const ws = that.ws
            if (!ws) {
                reject("Brayns is not connected!")
                return
            }
            const onProgress = (arg: { amount: number, operation: string }) => {
                listeners.fire({
                    label: arg.operation || "Loading...",
                    progress: arg.amount
                })
            }
            const onMessage = (arg: any) => {
                that.unsubscribe("progress", onProgress)
                resolve({
                    status: "ok",
                    message: arg
                })
            }
            const onError = (arg: { code: number, message: string }) => {
                if (arg.code === -31002) {
                    resolve({ status: "cancel", message: arg.message })
                } else {
                    console.error(`Error while calling method "${method}" with these params: `, params)
                    console.error(arg)
                    reject(arg)
                }
            }
            that.subscribe("progress", onProgress)

            const protocol = {
                jsonrpc: "2.0",
                id,
                method,
                params
            }

            that.queries[id] = { id, method, params, resolve: onMessage, reject: onError }
            ws.send(JSON.stringify(protocol));
        })

        return {
            cancel() {
                const ws = that.ws
                if (!ws) return
                ws.send(JSON.stringify({
                    jsonrpc: "2.0",
                    method: "cancel",
                    params: { id }
                }));
            },
            get progress(): Listeners<{ label: string, progress: number }> { return listeners },
            get promise() { return promise }
        }
    }

    sendChunk(data: ArrayBuffer) {
        const { ws } = this
        if (!ws) return

        ws.send(data)
    }

    /**
     * Brayns service will notify us on updates.
     * You can subscribe to receive updates for a specific method.
     */
    subscribe(method: string, listener: (arg: any) => void) {
        if (!this.subscribers[method]) {
            this.subscribers[method] = new Listeners<{}>()
        }
        this.subscribers[method].add(listener)
    }

    /**
     * Unsubscribe for specific updates.
     */
    unsubscribe(method: string, listener: (arg: any) => void) {
        if (!this.subscribers[method]) return
        this.subscribers[method].remove(listener)
    }

    get hostname() { return this.host }

    private handleOpen = (event: Event) => {
        this.readyListeners.fire(true)
    }

    private handleMessage = (event: MessageEvent) => {
        if (typeof event.data === 'string') {
            this.handleStringMessage(event.data)
        } else {
            this.binaryListeners.fire(event.data)
        }
    }

    private handleStringMessage(text: string) {
        try {
            const data = JSON.parse(text)
            const { id, method, result, params, error } = data;
            if (typeof id === 'undefined') {
                this.handleUpdate(method, params)
            }
            else if (typeof error !== 'undefined') {
                this.handleResponseError(id, error)
            }
            else {
                this.handleResponse(id, result);
            }
        }
        catch (ex) {
            console.error("Unable to parse websocket incoming message:", ex)
            console.error("    text = ", text)
        }
    }

    private handleUpdate(method: string, params: {}) {
        const listeners = this.subscribers[method];
        if (!listeners) {
            return
        }
        listeners.fire(params)
    }

    private handleResponse(id: string, params: string) {
        const query = this.queries[id]
        if (typeof query === 'undefined') {
            // Just ignore this message because it is not a response
            // to any of our queries.
            return;
        }

        delete this.queries[id]
        query.resolve(params);
    }

    private handleResponseError(id: string, error: any) {
        const query = this.queries[id]
        if (typeof query === 'undefined') {
            // Just ignore this message because it is not a response
            // to any of our queries.
            return;
        }

        console.error(`Error while calling "${query.method}" with params: "`, query.params)
        console.error("  >>> ", error)

        delete this.queries[id]
        query.reject({
            code: error.code || 0,
            message: error.message || "Unknown error!"
        });
    }

    private handleClose = async (event: Event) => {
        console.log('### [WS] Close:', event)
        this.readyListeners.fire(false)
        const retryConnection = await Tfw.Factory.Dialog.confirm(
            "Try to reconnect",
            <div>
                <p><b>Connection with Brayns Service has been lost!</b></p>
                <p>Do you want to try to reconnect?</p>
            </div>)
        if (retryConnection) {
            window.setTimeout(() => window.location.reload(), 250)
        } else {
            window.location.search = ''
        }
    }

    private handleError = (event: Event) => {
        console.error('### [WS] Error:', event)
    }
}
